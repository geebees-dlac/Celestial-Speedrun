<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Manual: Project T - Block Code</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3, h4 {
            color: #333;
        }
        h1 {
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
            text-align: center;
        }
        h2 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        h3 {
            margin-top: 20px;
        }
        code {
            background-color: #eef;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: Consolas, "Courier New", monospace;
        }
        pre {
            background-color: #2d2d2d;
            color: #f0f0f0;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: Consolas, "Courier New", monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            color: inherit;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        ul, ol {
            margin-left: 20px;
        }
        .toc {
            background-color: #e9f5ff;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        .toc h2 {
            border-bottom: none;
            margin-top: 0;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc ul li a {
            text-decoration: none;
            color: #007bff;
        }
        .toc ul li a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Game Manual: Project T - Block Code</h1>

        <div class="toc">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#introduction">1. Introduction</a>
                    <ul>
                        <li><a href="#intro-purpose">1.1 Purpose of this Manual</a></li>
                        <li><a href="#intro-core-systems">1.2 Core Game Systems Overview</a></li>
                    </ul>
                </li>
                <li><a href="#core-data-structures">2. Core Data Structures & Enums</a>
                    <ul>
                        <li><a href="#core-physics-types">2.1 <code>PhysicsTypes.hpp</code> - Understanding <code>phys::bodyType</code></a></li>
                        <li><a href="#core-collision-system-structs">2.2 <code>CollisionSystem.hpp</code> - <code>CollisionEvent</code> & <code>CollisionResolutionInfo</code></a></li>
                        <li><a href="#core-level-manager-structs">2.3 <code>LevelManager.hpp</code> - <code>LevelData</code> and its sub-structs</a></li>
                    </ul>
                </li>
                <li><a href="#body-types-debugging">3. Body Types Debugging</a>
                    <ul>
                        <li><a href="#body-types-identifying">3.1 Identifying Body Types in Game</a></li>
                        <li><a href="#body-types-behaviors">3.2 Expected Behaviors & Common Issues</a></li>
                    </ul>
                </li>
                <li><a href="#player-debugging">4. Player Debugging</a>
                    <ul>
                        <li><a href="#player-state-vars">4.1 Player State Variables</a></li>
                        <li><a href="#player-movement-collision">4.2 Movement & Collision Issues</a></li>
                        <li><a href="#player-interaction-problems">4.3 Interaction Problems</a></li>
                    </ul>
                </li>
                <li><a href="#level-debugging">5. Level Debugging</a>
                    <ul>
                        <li><a href="#level-loading-process">5.1 Level Loading Process</a></li>
                        <li><a href="#level-json-errors">5.2 Common JSON Configuration Errors</a></li>
                        <li><a href="#level-platform-setup">5.3 Platform-Specific Setup Issues</a></li>
                    </ul>
                </li>
                <li><a href="#game-state-debugging">6. Game State Debugging</a>
                    <ul>
                        <li><a href="#game-state-understanding">6.1 Understanding Game States</a></li>
                        <li><a href="#game-state-transitions-ui">6.2 Transitions & UI</a></li>
                        <li><a href="#game-state-audio">6.3 Music & SFX States</a></li>
                        <li><a href="#game-state-debug-issues">6.4 Debugging Game State Issues</a></li>
                    </ul>
                </li>
                <li><a href="#optimizer">7. Optimizer (Easing Functions)</a>
                    <ul>
                        <li><a href="#optimizer-what-are">7.1 What are Easing Functions?</a></li>
                        <li><a href="#optimizer-how-used">7.2 How They're Used in This Game</a></li>
                        <li><a href="#optimizer-file">7.3 The <code>Optimizer.hpp</code> File</a></li>
                    </ul>
                </li>
                <li><a href="#detailed-systems">8. Detailed System Explanations</a>
                    <ul>
                        <li><a href="#detailed-collision-system">8.1. <code>CollisionSystem.hpp</code> and <code>.cpp</code></a></li>
                        <li><a href="#detailed-level-manager">8.2. <code>LevelManager.hpp</code> and <code>.cpp</code></a></li>
                        <li><a href="#detailed-platform-body">8.3. <code>PlatformBody.hpp</code> and <code>.cpp</code></a></li>
                        <li><a href="#detailed-player">8.4. <code>Player.hpp</code> and <code>.cpp</code> (DynamicBody)</a></li>
                        <li><a href="#detailed-tile">8.5. <code>Tile.hpp</code> and <code>.cpp</code></a></li>
                    </ul>
                </li>
                <li><a href="#main-game-loop">9. Main Game Loop (<code>main.cpp</code>) Overview</a>
                     <ul>
                        <li><a href="#main-loop-init">9.1 Game Initialization</a></li>
                        <li><a href="#main-loop-event">9.2 Event Handling</a></li>
                        <li><a href="#main-loop-fixed-update">9.3 Fixed Update Loop</a></li>
                        <li><a href="#main-loop-transition">9.4 Transition Handling</a></li>
                        <li><a href="#main-loop-drawing">9.5 Drawing</a></li>
                    </ul>
                </li>
                <li><a href="#general-debugging-tips">10. General Debugging Tips</a></li>
            </ul>
        </div>

        <h2 id="introduction">1. Introduction</h2>
        <h3 id="intro-purpose">1.1 Purpose of this Manual</h3>
        <p>This manual is designed to help developers understand the internal workings of the "Project T" block-based platformer game. It provides explanations of core systems, data structures, and offers guidance for debugging common issues.</p>

        <h3 id="intro-core-systems">1.2 Core Game Systems Overview</h3>
        <ul>
            <li><strong>Physics & Collision (<code>CollisionSystem</code>, <code>DynamicBody</code>, <code>PlatformBody</code>):</strong> A custom AABB-based collision detection and resolution system. The player (<code>DynamicBody</code>) interacts with various types of platforms (<code>PlatformBody</code>).</li>
            <li><strong>Level Management (<code>LevelManager</code>):</strong> Handles loading level data from JSON files, managing level transitions (with fades and loading screens), and storing level-specific configurations.</li>
            <li><strong>Visuals (<code>Tile</code>, SFML):</strong> <code>Tile</code> objects represent platforms visually. SFML is used for rendering, windowing, input, and audio.</li>
            <li><strong>Game Logic (<code>main.cpp</code>):</strong> Contains the main game loop, player input handling, state management (<code>GameState</code>), and specific behaviors for different <code>bodyType</code>s (moving platforms, falling blocks, interactibles, etc.).</li>
            <li><strong>Easing (<code>Optimizer.hpp</code>):</strong> A utility library for smooth animation curves, currently used for moving platforms.</li>
        </ul>

        <h2 id="core-data-structures">2. Core Data Structures & Enums</h2>
        <h3 id="core-physics-types">2.1 <code>PhysicsTypes.hpp</code> - Understanding <code>phys::bodyType</code></h3>
        <p>This enum defines all the different kinds of physical objects/platforms that can exist in the game. Each type has distinct behaviors and collision properties.</p>
        <ul>
            <li><code>none</code> (0): Empty space, non-collidable. Used for vanishing platforms when they've disappeared.</li>
            <li><code>platform</code> (1): One-way platform. Player can jump through from below but lands on top. Can drop through with 'S' key.</li>
            <li><code>conveyorBelt</code> (2): Solid platform that applies a <code>surfaceVelocity</code> to the player.</li>
            <li><code>moving</code> (3): Platform that moves along a defined axis and path, usually with easing.</li>
            <li><code>interactible</code> (4): A platform that, when the player presses 'E' on it, can change its own type (e.g., become solid/none) or trigger other events (not fully implemented for 'other events').</li>
            <li><code>falling</code> (5): A platform that starts falling (visually via <code>Tile</code>) after a delay when the player lands on it. Becomes <code>none</code> after falling off-screen.</li>
            <li><code>vanishing</code> (6): Platforms that cyclically fade in and out, becoming <code>none</code> (non-collidable) when faded out and <code>vanishing</code> (collidable) when faded in.</li>
            <li><code>spring</code> (7):  Bounces the player significantly higher than a normal jump.</li>
            <li><code>trap</code> (8):   Kills the player on contact.</li>
            <li><code>solid</code> (9):   A standard, four-way collidable block.</li>
            <li><code>goal</code> (10): Interacting with this block (pressing 'E') advances to the next level or ends the game.</li>
            <li><code>portal</code> (11): <em>Intended functionality: Teleports player. Actual implementation in <code>main.cpp</code> for teleportation seems missing, but the <code>PlatformBody</code> has <code>portalID</code> and <code>teleportOffset</code> fields.</em> (User Note: Check <code>main.cpp</code> if portal logic was added/needed.)</li>
        </ul>

        <h3 id="core-collision-system-structs">2.2 <code>CollisionSystem.hpp</code> - <code>CollisionEvent</code> & <code>CollisionResolutionInfo</code></h3>
        <h4><code>struct CollisionEvent</code>:</h4>
        <ul>
            <li><code>time</code>: Time of impact (0.0 to 1.0, relative to the movement for the current physics step).</li>
            <li><code>axis</code>: The axis of collision (0 for X-axis normal, 1 for Y-axis normal).</li>
            <li><code>hitPlatform</code>: Pointer to the <code>PlatformBody</code> that was hit.</li>
        </ul>
        <h4><code>struct CollisionResolutionInfo</code>:</h4>
        <ul>
            <li><code>onGround</code>: True if the player landed on a surface.</li>
            <li><code>hitCeiling</code>: True if the player hit a ceiling.</li>
            <li><code>hitWallLeft</code> / <code>hitWallRight</code>: True if the player hit a wall.</li>
            <li><code>surfaceVelocity</code>: Velocity of the surface the player is on (e.g., for conveyor belts).</li>
            <li><code>groundPlatform</code>: Pointer to the <code>PlatformBody</code> the player is currently on.</li>
        </ul>

        <h3 id="core-level-manager-structs">2.3 <code>LevelManager.hpp</code> - <code>LevelData</code> and its sub-structs</h3>
        <p>This structure holds all the data loaded from a level's JSON file.</p>
        <ul>
            <li><code>std::string levelName</code>: Display name of the level.</li>
            <li><code>int levelNumber</code>: The numerical identifier of the level.</li>
            <li><code>sf::Vector2f playerStartPosition</code>: Where the player spawns.</li>
            <li><code>sf::Color backgroundColor</code>: Background color for the level.</li>
            <li><code>std::vector<phys::PlatformBody> platforms</code>: The primary list of all platforms defined in the level. Each <code>PlatformBody</code> here contains its ID, position, size, type, etc.</li>
            <li><strong><code>MovingPlatformInfo</code></strong>: Defines behavior for a <code>moving</code> platform.
                <ul>
                    <li><code>id</code>: Matches the <code>id</code> of a <code>PlatformBody</code> in the <code>platforms</code> vector.</li>
                    <li><code>startPosition</code>: Anchor position for movement calculations (can differ from the initial platform position in JSON if initialDirection and cycleTime imply an offset start).</li>
                    <li><code>axis</code>: 'x' or 'y'.</li>
                    <li><code>distance</code>: Total distance of movement in one direction from the anchor.</li>
                    <li><code>cycleDuration</code>: Time for a full back-and-forth cycle.</li>
                    <li><code>initialDirection</code>: 1 or -1, determining the starting direction of movement.</li>
                </ul>
            </li>
            <li><strong><code>InteractiblePlatformInfo</code></strong>: Defines behavior for an <code>interactible</code> platform.
                <ul>
                    <li><code>id</code>: Matches the <code>id</code> of a <code>PlatformBody</code>.</li>
                    <li><code>interactionType</code>: e.g., "changeSelf".</li>
                    <li><code>targetBodyTypeStr</code>: String representation of the <code>phys::bodyType</code> the platform changes to.</li>
                    <li><code>targetTileColor</code>: Optional color the tile changes to.</li>
                    <li><code>oneTime</code>: If true, interaction works only once per level load.</li>
                    <li><code>cooldown</code>: Time before it can be interacted with again (if not <code>oneTime</code>).</li>
                    <li><code>linkedID</code>: (Potential for future use, e.g., one interactible triggers another specific platform.)</li>
                </ul>
            </li>
             <li><strong><code>PortalPlatformInfo</code></strong>: Defines behavior for a <code>portal</code> platform.
                <ul>
                    <li><code>id</code>: Matches the <code>id</code> of a <code>PlatformBody</code>.</li>
                    <li><code>portalID</code>: Links this portal to another <code>PlatformBody</code> with the same <code>portalID</code>.</li>
                    <li><code>offset</code>: Teleportation offset relative to the target portal's position.</li>
                </ul>
            </li>
        </ul>


        <h2 id="body-types-debugging">3. Body Types Debugging</h2>
        <h3 id="body-types-identifying">3.1 Identifying Body Types in Game</h3>
        <ul>
            <li><strong>Visual Color:</strong> The primary way to quickly identify a <code>bodyType</code> is by its color, defined in <code>getTileColorForBodyType()</code> in <code>main.cpp</code>. For example, solid is grey, platform is blue-ish, trap is red.</li>
            <li><strong>Debug Text:</strong> The in-game debug text (top-left) shows information about the platform the player is standing on, including its ID and <code>bodyType</code> (as an integer).
                <br>Example: <code>Ground: Y (ID:123 Type:9)</code> means standing on a solid block with ID 123.
            </li>
        </ul>

        <h3 id="body-types-behaviors">3.2 Expected Behaviors & Common Issues</h3>
        <table>
            <thead>
                <tr>
                    <th>Type</th>
                    <th>Expected Behavior</th>
                    <th>Common Issues & Debug Checks</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>none</code></td>
                    <td>Invisible, non-collidable.</td>
                    <td>N/A (usually the <em>result</em> of another action like vanishing).</td>
                </tr>
                <tr>
                    <td><code>platform</code></td>
                    <td>One-way (top collision only), can drop through. Color: Translucent Blue.</td>
                    <td>Player passes through top: Check <code>CollisionSystem::sweptAABB</code> logic for <code>bodyType::platform</code>. <code>JUMP_THROUGH_TOLERANCE</code>. Is player dropping?</td>
                </tr>
                <tr>
                    <td><code>conveyorBelt</code></td>
                    <td>Solid, moves player horizontally. Color: Orange.</td>
                    <td>Player not moving: Check <code>surfaceVelocity</code> in JSON. Check <code>main.cpp</code> player update when <code>isOnGround</code> and <code>pf.getType() == phys::bodyType::conveyorBelt</code>.</td>
                </tr>
                <tr>
                    <td><code>moving</code></td>
                    <td>Moves along a path. Color: Green.</td>
                    <td>Not moving/wrong path: Check JSON <code>movement</code> details for the ID. Check <code>activeMovingPlatforms</code> update in <code>main.cpp</code>. Is easing correct?</td>
                </tr>
                <tr>
                    <td><code>interactible</code></td>
                    <td>Responds to 'E' key. Color: Light Purple/Blue.</td>
                    <td>No interaction: Is player AABB intersecting? Is <code>interactKeyPressedThisFrame</code> true? Cooldown active? <code>oneTime</code> already used? JSON <code>interaction</code> details correct for ID? <code>targetBodyTypeStr</code> valid?</td>
                </tr>
                <tr>
                    <td><code>falling</code></td>
                    <td>Falls after player lands. Color: Yellow.</td>
                    <td>Not falling: Is <code>template_body_ptr->getType() == phys::bodyType::falling</code>? Is player actually on <em>this</em> tile? Is <code>Tile::startFalling()</code> called? <code>Tile::update()</code> logic for <code>m_isFalling</code>/<code>m_hasFallen</code>.</td>
                </tr>
                <tr>
                    <td><code>vanishing</code></td>
                    <td>Fades in/out, collidable when visible. Color: Purple.</td>
                    <td>Not vanishing/always solid: Check <code>template_body_ptr->getType() == phys::bodyType::vanishing</code>. Check <code>vanishingPlatformCycleTimer</code> and <code>oddEvenVanishing</code> logic in <code>main.cpp</code>. Alpha calculation & <code>setType(phys::bodyType::none)</code> logic correct? <code>originalPos</code> being set correctly?</td>
                </tr>
                <tr>
                    <td><code>spring</code></td>
                    <td>High bounce. Color: Bright Yellow.</td>
                    <td>No bounce/normal jump: Check <code>main.cpp</code> player update: <code>pf.getType() == phys::bodyType::spring</code>. Velocity set to <code>SPRING_BOUNCE_VELOCITY</code>? <code>playSfx("spring")</code>?</td>
                </tr>
                <tr>
                    <td><code>trap</code></td>
                    <td>Kills player. Color: Red.</td>
                    <td>Player not dying: Check <code>main.cpp</code> trap check: <code>body_check_trap.getAABB().intersects(playerBody.getAABB())</code>. <code>playSfx("death")</code>?</td>
                </tr>
                <tr>
                    <td><code>solid</code></td>
                    <td>Standard block. Color: Grey.</td>
                    <td>Collisions not working: Unlikely if other types work. Fallback is <code>sweptAABB</code> generic resolution.</td>
                </tr>
                <tr>
                    <td><code>goal</code></td>
                    <td>Ends level/game on 'E' press. Color: Translucent Green.</td>
                    <td>Can't finish level: Player intersecting? <code>interactKeyPressedThisFrame</code>? <code>LevelManager::requestLoadNextLevel</code> or <code>GAME_OVER_WIN</code> logic. <code>playSfx("goal")</code>?</td>
                </tr>
                 <tr>
                    <td><code>portal</code></td>
                    <td>Teleports player (intended). Color varies (defaults to magenta if not overridden or on error).</td>
                    <td>Teleport not working: Is this feature implemented in <code>main.cpp</code>? (Current <code>main.cpp</code> provided does not show player-portal interaction logic to teleport.) Platform JSON needs <code>portalID</code> and optional <code>teleportOffset</code> fields. Check that an actual <code>PlatformBody</code> with matching <code>portalID</code> exists as a target.</td>
                </tr>
            </tbody>
        </table>

        <h2 id="player-debugging">4. Player Debugging (<code>phys::DynamicBody</code>)</h2>
        <p>The player is an instance of <code>phys::DynamicBody</code>.</p>
        <h3 id="player-state-vars">4.1 Player State Variables (in <code>DynamicBody</code> and <code>main.cpp</code>):</h3>
        <ul>
            <li><code>m_position</code>: Current top-left corner of the player.</li>
            <li><code>m_velocity</code>: Current speed and direction.</li>
            <li><code>m_lastPosition</code>: Position at the start of the previous fixed update. Used by collision system.</li>
            <li><code>m_width</code>, <code>m_height</code>: Dimensions of the player.</li>
            <li><code>m_onGround</code>: Boolean, true if the <code>CollisionSystem</code> determined the player is on a surface. Crucial for jumping, gravity application.</li>
            <li><code>m_groundPlatform</code>: Pointer to the <code>PlatformBody</code> the player is currently on. Can be <code>nullptr</code>.</li>
            <li><code>m_isTryingToDrop</code>: Boolean, set if the player presses 'S'/'Down' while on ground. Used to ignore collision with <code>bodyType::platform</code>.</li>
            <li><code>m_tempIgnoredPlatform</code>: Pointer to a platform being temporarily ignored (e.g., when dropping through).</li>
            <li><code>currentJumpHoldDuration</code> (<code>main.cpp</code>): Tracks how long the jump button has been held for variable jump height.</li>
            <li><code>turboMultiplier</code> (<code>main.cpp</code>): Increases movement speed when shift is pressed.</li>
        </ul>

        <h3 id="player-movement-collision">4.2 Movement & Collision Issues:</h3>
        <ul>
            <li><strong>Not Moving/Jumping:</strong>
                <ul>
                    <li>Check keyboard input detection in <code>main.cpp</code> (A, D, W, Space, etc.).</li>
                    <li>Is <code>PLAYER_MOVE_SPEED</code>, <code>JUMP_INITIAL_VELOCITY</code> non-zero?</li>
                    <li>For jumping: Is <code>playerBody.isOnGround()</code> true? Is <code>newJumpPressThisFrame</code> true?</li>
                    <li>If stuck: Is <code>playerBody.getVelocity()</code> getting zeroed out unexpectedly by <code>CollisionSystem::applyCollisionResponse</code>? Print velocity before and after <code>resolveCollisions</code>.</li>
                </ul>
            </li>
            <li><strong>Passing Through Platforms:</strong>
                <ul>
                    <li>Is the platform <code>bodyType</code> correct (e.g., not <code>none</code>)?</li>
                    <li><code>CollisionSystem::sweptAABB</code>: Is it correctly detecting a collision? Print <code>entryTime</code>, <code>exitTime</code>, <code>firstEntry</code>. The <code>displacement</code> vector passed to it is key.</li>
                    <li>Is <code>CollisionSystem::resolveCollisions</code> correctly applying the hit? Are iterations too few?</li>
                    <li>Is it a one-way platform (<code>bodyType::platform</code>) and logic for landing is failing (e.g. <code>canLandOnOneWay</code> conditions)?</li>
                    <li>Is <code>playerBody.isTryingToDropFromPlatform()</code> true when it shouldn't be?</li>
                </ul>
            </li>
            <li><strong>Stuck to Walls/Ceiling:</strong>
                <ul>
                    <li><code>CollisionSystem::applyCollisionResponse</code>: Ensure it zeros out velocity on the correct axis.</li>
                    <li>Depenetration logic: <code>DEPENETRATION_BIAS</code>. Is it pushing the player correctly? Print correction vector.</li>
                </ul>
            </li>
            <li><strong>Weird Gravity/Fall Speed:</strong>
                <ul>
                    <li><code>GRAVITY_ACCELERATION</code>: Value correct? Applied only when <code>!playerBody.isOnGround()</code>?</li>
                    <li><code>MAX_FALL_SPEED</code>: Is it being clamped correctly?</li>
                </ul>
            </li>
        </ul>

        <h3 id="player-interaction-problems">4.3 Interaction Problems (Mainly with platforms, 'E' key):</h3>
        <ul>
            <li><strong>Not Interacting with Goal/Interactible:</strong>
                <ul>
                    <li>Is <code>interactKeyPressedThisFrame</code> (in <code>main.cpp</code>) true?</li>
                    <li>Is <code>playerBody.getAABB().intersects(platform_body.getAABB())</code> true?</li>
                    <li>For Interactibles:
                        <ul>
                            <li>Check <code>activeInteractibles[id].currentCooldownTimer</code>.</li>
                            <li>Check <code>activeInteractibles[id].oneTime</code> and <code>hasBeenInteractedThisSession</code>.</li>
                            <li>Is the <code>interactionType</code> correctly handled (e.g., "changeSelf")?</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h2 id="level-debugging">5. Level Debugging</h2>
        <h3 id="level-loading-process">5.1 Level Loading Process:</h3>
        <ol>
            <li><strong>Request:</strong> e.g., <code>levelManager.requestLoadNextLevel(currentLevelData)</code> called from <code>main.cpp</code>.</li>
            <li><code>LevelManager</code> state becomes <code>FADING_OUT</code>. <code>m_fadeOverlay</code> alpha increases.</li>
            <li>On fade complete, state becomes <code>LOADING</code>.
                <ul>
                    <li>Appropriate loading screen image is loaded.</li>
                    <li><code>performActualLoad(targetLevelNumber, outLevelData)</code> is called.
                        <ul>
                            <li><code>loadLevelDataFromFile(filename, outLevelData)</code>
                                <ul>
                                    <li><code>readJsonFile(filepath)</code>: Opens and parses the JSON using RapidJSON.</li>
                                    <li><code>parseLevelData(doc, outLevelData)</code>: Extracts data from JSON document into <code>outLevelData</code> struct. This is where most per-platform setup occurs by populating <code>outLevelData.platforms</code>, <code>movingPlatformDetails</code>, etc.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>On successful load, <code>m_currentLevelNumber</code> is updated, state becomes <code>FADING_IN</code>. <code>m_fadeOverlay</code> alpha decreases.</li>
            <li>On fade-in complete, <code>LevelManager</code> state becomes <code>NONE</code>. <code>main.cpp</code> calls <code>setupLevelAssets()</code> using <code>currentLevelData</code>.</li>
        </ol>

        <h3 id="level-json-errors">5.2 Common JSON Configuration Errors:</h3>
        <ul>
            <li><strong>File Not Found:</strong>
                <ul>
                    <li>Verify <code>m_levelBasePath</code> in <code>LevelManager</code> (default: <code>../assets/levels/</code>).</li>
                    <li>Ensure JSON files are named <code>level1.json</code>, <code>level2.json</code>, etc.</li>
                    <li>Check console for "Could not open JSON file" or "Error parsing JSON".</li>
                </ul>
            </li>
            <li><strong>Syntax Errors in JSON:</strong>
                <ul>
                    <li>Missing commas, mismatched brackets/braces, incorrect data types (e.g., string where number expected).</li>
                    <li>RapidJSON parse errors in console usually point to the offset.</li>
                </ul>
            </li>
            <li><strong>Missing Required Fields:</strong>
                <ul>
                    <li><code>platforms</code> array: Must exist.</li>
                    <li>Platform objects: Should ideally have <code>id</code>, <code>position</code> (<code>x</code>, <code>y</code>), <code>size</code> (<code>width</code>, <code>height</code>), <code>type</code>. <code>LevelManager::parseLevelData</code> has some defaults/warnings for missing optional fields.</li>
                    <li>Specific types (<code>moving</code>, <code>interactible</code>, <code>portal</code>): Missing their specific sub-blocks (<code>movement</code>, <code>interaction</code>, <code>portalID</code>) will mean default/no special behavior. ID in sub-block must match main platform ID.</li>
                </ul>
            </li>
            <li><strong>Incorrect <code>bodyType</code> String:</strong>
                <ul>
                    <li>e.g., "solidd" instead of "solid". <code>LevelManager::stringToBodyType</code> will warn and default to <code>solid</code>.</li>
                </ul>
            </li>
            <li><strong>Logical Errors:</strong>
                <ul>
                    <li>Moving platform <code>distance</code> too small/large.</li>
                    <li>Interactible <code>targetBodyTypeStr</code> points to an undesirable type.</li>
                    <li>Player start position inside a solid block.</li>
                </ul>
            </li>
        </ul>

        <h3 id="level-platform-setup">5.3 Platform-Specific Setup Issues (after JSON is parsed correctly):</h3>
        <ul>
            <li><strong>Moving Platforms Not Moving:</strong>
                <ul>
                    <li>In <code>setupLevelAssets()</code>: Is an <code>ActiveMovingPlatform</code> entry created for its ID?</li>
                    <li>In <code>main.cpp</code>'s fixed update: Is <code>activePlat.cycleTime</code> updating? Is <code>math::easing::sineEaseInOut</code> producing correct offsets? Is <code>movingBodyPtr->setPosition()</code> called?</li>
                    <li>Ensure the platform's <code>bodyType</code> in JSON is "moving" AND a "movement" block with matching ID exists.</li>
                </ul>
            </li>
            <li><strong>Interactible Platforms Not Responding:</strong>
                <ul>
                    <li>In <code>setupLevelAssets()</code>: Is an <code>ActiveInteractiblePlatform</code> entry created for its ID?</li>
                    <li>Logic in <code>main.cpp</code>'s 'E' key press handling (cooldowns, <code>oneTime</code> flag).</li>
                    <li>Is <code>interact_body_ref.setType()</code> and <code>tiles[k].setFillColor()</code> working as expected?</li>
                </ul>
            </li>
            <li><strong>Falling Platforms Not Falling:</strong>
                <ul>
                    <li>In <code>setupLevelAssets()</code>: Are tiles created correctly?</li>
                    <li>In <code>main.cpp</code>'s fixed update, section "Update Platform States (Falling, Vanishing)":
                        <ul>
                            <li>Is <code>template_body_ptr->getType()</code> actually <code>phys::bodyType::falling</code>?</li>
                            <li>Is <code>playerOnThis</code> check correct?</li>
                            <li>Is <code>current_tile.startFalling()</code> called?</li>
                            <li>Is <code>current_tile.update()</code> progressing <code>m_isFalling</code> and <code>m_hasFallen</code>?</li>
                            <li>Is <code>current_body.setType(phys::bodyType::none)</code> happening when <code>current_tile.hasFallen()</code>?</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><strong>Vanishing Platforms Not Vanishing/Reappearing:</strong>
                <ul>
                    <li>In <code>main.cpp</code>'s fixed update, "Update Platform States":
                        <ul>
                            <li><code>template_body_ptr->getType()</code> must be <code>phys::bodyType::vanishing</code>.</li>
                            <li><code>oddEvenVanishing</code> logic and <code>vanishingPlatformCycleTimer</code>.</li>
                            <li>Alpha calculation (<code>math::easing::sineEaseInOut</code>).</li>
                            <li>Conditional logic:
                                <ul>
                                    <li>If <code>alpha_val <= 10.f</code>: set to <code>bodyType::none</code>, move off-screen.</li>
                                    <li>Else: set to <code>bodyType::vanishing</code>, move to <code>originalPos</code>.</li>
                                </ul>
                            </li>
                            <li>Crucially, is <code>originalPos</code> being correctly fetched from <code>currentLevelData.platforms</code> using the body's ID? If <code>originalPos</code> is bad, the platform won't reappear correctly.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>


        <h2 id="game-state-debugging">6. Game State Debugging (<code>GameState</code> enum in <code>main.cpp</code>)</h2>
        <h3 id="game-state-understanding">6.1 Understanding Game States:</h3>
        <ul>
            <li><code>MENU</code>: Main menu screen. Handles navigation to Start, Settings, Credits, Exit.</li>
            <li><code>SETTINGS</code>: Settings screen (volume, resolution).</li>
            <li><code>CREDITS</code>: Credits screen.</li>
            <li><code>PLAYING</code>: Active gameplay. Player control, physics updates, interactions.</li>
            <li><code>TRANSITIONING</code>: Level loading is in progress (fades, loading screen displayed by <code>LevelManager</code>).</li>
            <li><code>GAME_OVER_WIN</code>: Player has completed all levels.</li>
            <li><code>GAME_OVER_LOSE_FALL</code>: Player fell off the level.</li>
            <li><code>GAME_OVER_LOSE_DEATH</code>: Player hit a trap.</li>
        </ul>

        <h3 id="game-state-transitions-ui">6.2 Transitions & UI:</h3>
        <p>State changes are triggered by player actions (button clicks, specific game events like dying or reaching goal).
        The <code>draw</code> section in <code>main.cpp</code> uses a <code>switch(currentState)</code> to render the appropriate UI, views, and game elements.
        When <code>currentState == GameState::TRANSITIONING</code>, <code>levelManager.update()</code> and <code>levelManager.draw()</code> handle the visual transition. Once <code>levelManager.isTransitioning()</code> is false, <code>main.cpp</code> sets <code>currentState = GameState::PLAYING</code> and calls <code>setupLevelAssets()</code>.</p>

        <h3 id="game-state-audio">6.3 Music & SFX States:</h3>
        <ul>
            <li><code>menuMusic</code> and <code>gameMusic</code> are controlled based on <code>currentState</code>.
                <ul>
                    <li><code>MENU</code>, <code>GAME_OVER_*</code>: <code>menuMusic</code> plays, <code>gameMusic</code> stops/pauses.</li>
                    <li><code>PLAYING</code>, <code>TRANSITIONING</code> (to play): <code>gameMusic</code> plays, <code>menuMusic</code> stops.</li>
                </ul>
            </li>
            <li>SFX (<code>sfxPlayer</code>) are played for specific actions (<code>jump</code>, <code>death</code>, <code>goal</code>, <code>click</code>). Volume controlled by <code>gameSettings.sfxVolume</code>.</li>
        </ul>

        <h3 id="game-state-debug-issues">6.4 Debugging Game State Issues:</h3>
        <ul>
            <li><strong>Stuck in a State:</strong>
                <ul>
                    <li>Print <code>currentState</code> continuously or use a debugger.</li>
                    <li><code>TRANSITIONING</code>: Check <code>levelManager.isTransitioning()</code>. Is <code>LevelManager::update()</code> being called? Does it ever reach <code>m_transitionState = TransitionState::NONE</code>? Check for errors during level loading.</li>
                    <li><code>MENU</code>/<code>SETTINGS</code>/<code>CREDITS</code>/<code>GAME_OVER</code>: Is event handling for mouse clicks or Escape key working? Are button <code>getGlobalBounds().contains(worldPosUi)</code> checks correct?</li>
                </ul>
            </li>
            <li><strong>Wrong UI Displayed:</strong>
                <ul>
                    <li>Verify the <code>draw</code> logic for the current <code>currentState</code> in <code>main.cpp</code>. Is the correct <code>sf::View</code> active (<code>uiView</code> vs <code>mainView</code>)?</li>
                </ul>
            </li>
            <li><strong>Music Not Changing/Playing:</strong>
                <ul>
                    <li>Check the <code>if</code> conditions controlling <code>menuMusic.play/stop/pause</code> and <code>gameMusic.play/stop/pause</code> within state transition logic.</li>
                    <li>Are music files correctly loaded in <code>loadAudio()</code>? <code>menuMusic.openFromFile()</code> returning true?</li>
                    <li>Is <code>gameSettings.musicVolume</code> accidentally zero?</li>
                </ul>
            </li>
            <li><strong>Player Controllable in Menu/Transition:</strong> Input handling is typically guarded by <code>if (currentState == GameState::PLAYING)</code>. Ensure this is the case.</li>
        </ul>

        <h2 id="optimizer">7. Optimizer (Easing Functions - <code>Optimizer.hpp</code>)</h2>
        <h3 id="optimizer-what-are">7.1 What are Easing Functions?</h3>
        <p>Easing functions (also known as tweening functions) describe the rate of change of a parameter over time. Instead of a value changing linearly (at a constant speed), easing allows for acceleration, deceleration, or other more natural-looking or stylized motions.</p>
        <p>Example: A platform moving from point A to B might start slow, speed up, then slow down as it reaches B, rather than moving at a constant velocity.</p>

        <h3 id="optimizer-how-used">7.2 How They're Used in This Game:</h3>
        <ul>
            <li><strong>Moving Platforms:</strong> The primary use in <code>main.cpp</code> is for <code>ActiveMovingPlatform</code> updates.
                <pre><code>// In main.cpp, within the moving platform update logic:
offset = math::easing::sineEaseInOut(currentPhaseTime, /*start val*/, /*change in val*/, /*duration of this phase*/);
// This makes the platform smoothly oscillate.</code></pre>
            </li>
            <li><strong>Vanishing Platforms:</strong> Similar easing (<code>sineEaseInOut</code>) is used to control the alpha (transparency) of vanishing platforms for smooth fading in and out.</li>
        </ul>

        <h3 id="optimizer-file">7.3 The <code>Optimizer.hpp</code> File (effectively <code>Easing.hpp</code>):</h3>
        <ul>
            <li>This file contains a collection of "Robert Penner Easing Functions."</li>
            <li><strong>Standard (t, b, c, d) pattern:</strong>
                <ul>
                    <li><code>t</code>: current time elapsed for the animation phase.</li>
                    <li><code>b</code>: beginning value of the property being animated.</li>
                    <li><code>c</code>: change in value (end value - beginning value).</li>
                    <li><code>d</code>: total duration of the animation phase.</li>
                    <li>Functions like <code>math::easing::cubicEaseOut(t, b, c, d)</code> return the eased value at time <code>t</code>.</li>
                </ul>
            </li>
            <li><strong>Normalized Easing:</strong>
                <ul>
                    <li>Functions like <code>math::normalized_easing::expoEaseIn(alpha)</code> take an <code>alpha</code> value (normalized time, from 0.0 to 1.0). They return an eased alpha, also from 0.0 to 1.0.</li>
                    <li>This eased alpha can then be used with <code>math::lerp</code> (linear interpolation).</li>
                </ul>
            </li>
            <li><code>math::lerp(start, end, alpha)</code>: Linearly interpolates between <code>start</code> and <code>end</code> values based on <code>alpha</code>. If <code>alpha</code> is an eased alpha, the interpolation will be non-linear.</li>
        </ul>
        <p>The <code>Optimizer.cpp</code> file shows example usage but is not directly compiled into the game logic provided in <code>main.cpp</code>. The header (<code>Optimizer.hpp</code>) is what's used.</p>

        <h2 id="detailed-systems">8. Detailed System Explanations</h2>

        <h3 id="detailed-collision-system">8.1. <code>CollisionSystem.hpp</code> and <code>.cpp</code></h3>
        <h4>Purpose:</h4>
        <p>Detects and resolves collisions between a single <code>DynamicBody</code> (the player) and a list of <code>PlatformBody</code> objects.</p>
        <h4>Key Structures:</h4>
        <ul>
            <li><code>CollisionEvent</code>: Stores details of a single potential collision (time, axis, platform hit).</li>
            <li><code>CollisionResolutionInfo</code>: Summarizes the results of all collision resolutions for a frame (onGround, hitCeiling, etc.).</li>
        </ul>
        <h4><code>resolveCollisions(DynamicBody& dynamicBody, const std::vector<PlatformBody>& platformBodies, float deltaTime)</code>:</h4>
        <ol>
            <li><strong>Initialization:</strong> Clears <code>resolutionInfo</code>.</li>
            <li><strong>Iterative Resolution:</strong> Runs for <code>MAX_COLLISION_ITERATIONS</code> or until <code>timeRemaining</code> in <code>deltaTime</code> is consumed. This allows handling multiple collisions within a single physics step.
                <ul>
                    <li><strong>Sweep Vector:</strong> Calculates <code>sweepVector = dynamicBody.getVelocity() * timeRemaining</code>.</li>
                    <li><strong>Narrowphase (Swept AABB):</strong> For each platform:
                        <ul>
                            <li>Skips <code>goal</code>, <code>none</code>, <code>trap</code> types, and temporarily ignored platforms.</li>
                            <li>Performs an optional broadphase AABB check using the sweep vector.</li>
                            <li>Calls <code>sweptAABB()</code> to find the earliest collision (<code>currentEventDetails</code>) with that platform during the current sweep.</li>
                            <li><strong>One-Way Platform Logic:</strong> If <code>platform.getType() == phys::bodyType::platform</code>, additional checks are made:
                                <ul>
                                    <li><code>canLandOnOneWay</code>: Ensures player is moving downwards-ish and feet are near/above platform top.</li>
                                    <li>Drop-Through: If player is trying to drop (<code>dynamicBody.isTryingToDropFromPlatform()</code>) from this specific platform, it's temporarily ignored.</li>
                                </ul>
                            </li>
                            <li>Updates <code>nearestCollisionEvent</code> if <code>currentEventDetails.time</code> is earlier.</li>
                        </ul>
                    </li>
                    <li><strong>Process Nearest Collision:</strong> If a <code>hitPlatformInIter</code> was found:
                        <ul>
                            <li>Move <code>dynamicBody</code> to the point of impact (<code>movementToCollision</code>).</li>
                            <li><code>applyCollisionResponse()</code>: Modifies <code>dynamicBody</code>'s velocity based on <code>nearestCollisionEvent.axis</code>.</li>
                            <li>Update <code>resolutionInfo</code> (onGround, hitCeiling, etc.).</li>
                            <li><strong>Depenetration:</strong> If <code>nearestCollisionEvent.time</code> is very small (overlap), calculates and applies a small correction to push <code>dynamicBody</code> out of the platform. <code>DEPENETRATION_BIAS</code> is used.</li>
                            <li>Updates <code>timeRemaining</code>.</li>
                        </ul>
                    </li>
                    <li><strong>No Collision:</strong> If no collision in iteration, move <code>dynamicBody</code> by the full <code>sweepVector</code> for the remaining time.</li>
                </ul>
            </li>
            <li><strong>Finalization:</strong> Updates <code>dynamicBody.setOnGround()</code> and <code>dynamicBody.setGroundPlatform()</code>. Returns <code>resolutionInfo</code>.</li>
        </ol>
        <h4><code>sweptAABB(const DynamicBody& body, const sf::Vector2f& displacement, const PlatformBody& platform, float maxTime, CollisionEvent& outCollisionEvent)</code>:</h4>
        <ul>
            <li>Calculates if and when a moving AABB (<code>body</code> + <code>displacement</code>) will collide with a static AABB (<code>platform</code>).</li>
            <li><strong>Static Overlap:</strong> If <code>displacement</code> is zero, checks for current intersection.</li>
            <li><strong>Dynamic Check:</strong>
                <ul>
                    <li>Calculates <code>entryTime</code> (when AABBs first touch on each axis) and <code>exitTime</code> (when AABBs last touch on each axis) for X and Y, normalized to the displacement (0 to 1 range).</li>
                    <li><code>firstEntry = std::max(entryTime.x, entryTime.y)</code>: Time of first overall contact.</li>
                    <li><code>lastExit = std::min(exitTime.x, exitTime.y)</code>: Time of last overall contact.</li>
                    <li><strong>Collision Condition:</strong> <code>firstEntry <= lastExit</code> AND <code>firstEntry < 1.0f</code> AND <code>lastExit > 0.0f</code>.</li>
                    <li>If collision:
                        <ul>
                            <li><code>outCollisionEvent.time = firstEntry</code>.</li>
                            <li><code>outCollisionEvent.hitPlatform = &platform</code>.</li>
                            <li><code>outCollisionEvent.axis</code>: Determined by which axis's <code>entryTime</code> was greater (or other heuristics for corner cases).</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <h4><code>applyCollisionResponse(DynamicBody& dynamicBody, const CollisionEvent& event, const PlatformBody& hitPlatform)</code>:</h4>
        <ul>
            <li>If <code>event.axis == 0</code> (hit vertical surface), sets <code>dynamicBody.getVelocity().x = 0.f</code>.</li>
            <li>If <code>event.axis == 1</code> (hit horizontal surface), sets <code>dynamicBody.getVelocity().y = 0.f</code>.</li>
        </ul>

        <h3 id="detailed-level-manager">8.2. <code>LevelManager.hpp</code> and <code>.cpp</code></h3>
        <h4>Purpose:</h4>
        <p>Manages loading level data from JSON files, orchestrating screen transitions between levels or game states, and providing access to loaded level data.</p>
        <h4>Key Members:</h4>
        <ul>
            <li><code>m_currentLevelNumber</code>, <code>m_targetLevelNumber</code>: Track loaded and requested levels.</li>
            <li><code>m_levelDataToFill</code>: Pointer to the <code>LevelData</code> struct (in <code>main.cpp</code>) to populate.</li>
            <li><code>m_levelBasePath</code>: Path to the levels directory.</li>
            <li><code>m_bodyTypeMap</code>: Maps string names of body types (from JSON) to <code>phys::bodyType</code> enum values.</li>
            <li><code>m_transitionState</code>: <code>TransitionState</code> enum (<code>NONE</code>, <code>FADING_OUT</code>, <code>LOADING</code>, <code>FADING_IN</code>).</li>
            <li><code>m_transitionClock</code>, <code>m_fadeDuration</code>: Control timing of fades.</li>
            <li><code>m_loadingTexture</code>, <code>m_loadingSprite</code>: For displaying loading screens. Paths stored in <code>m_generalLoadingScreenPath</code>, etc.</li>
            <li><code>m_fadeOverlay</code>: <code>sf::RectangleShape</code> used for fade effects.</li>
        </ul>
        <h4>Requesting Loads:</h4>
        <ul>
            <li><code>requestLoadLevel()</code>, <code>requestLoadSpecificLevel()</code>, <code>requestLoadNextLevel()</code>, <code>requestRespawnCurrentLevel()</code>:
                <ul>
                    <li>Set <code>m_targetLevelNumber</code>, <code>m_levelDataToFill</code>, <code>m_currentLoadType</code>.</li>
                    <li>Initiate transition by setting <code>m_transitionState = TransitionState::FADING_OUT</code> and restarting <code>m_transitionClock</code>.</li>
                </ul>
            </li>
        </ul>
        <h4><code>update(float dt, sf::RenderWindow& window)</code>:</h4>
        <p>Manages the <code>m_transitionState</code> machine:</p>
        <ul>
            <li><code>FADING_OUT</code>: Adjusts <code>m_fadeOverlay</code> alpha. On completion, switches to <code>LOADING</code>. Loads the chosen loading screen image. Calls <code>performActualLoad()</code>. If successful, switches to <code>FADING_IN</code>.</li>
            <li><code>LOADING</code>: (Brief state, actual load happens at end of FADING_OUT or start of it)</li>
            <li><code>FADING_IN</code>: Adjusts <code>m_fadeOverlay</code> alpha. On completion, switches to <code>NONE</code>.</li>
        </ul>
        <h4><code>draw(sf::RenderWindow& window)</code>:</h4>
        <p>Draws loading screen sprite and/or fade overlay if transitioning.</p>
        <h4><code>performActualLoad(int levelNumber, LevelData& outLevelData)</code>:</h4>
        <ul>
            <li>Constructs filename (e.g., <code>../assets/levels/level1.json</code>).</li>
            <li>Calls <code>loadLevelDataFromFile()</code>.</li>
        </ul>
        <h4><code>loadLevelDataFromFile(const std::string& filename, LevelData& outLevelData)</code>:</h4>
        <ul>
            <li>Calls <code>readJsonFile()</code> to get a <code>rapidjson::Document</code>.</li>
            <li>Calls <code>parseLevelData()</code> to populate <code>outLevelData</code>.</li>
            <li>Frees the document.</li>
        </ul>
        <h4><code>readJsonFile(const std::string& filepath)</code>:</h4>
        <p>Uses <code>fopen</code>, <code>rapidjson::FileReadStream</code>, and <code>doc.ParseStream()</code> to parse JSON. Handles file and parse errors.</p>
        <h4><code>parseLevelData(const rapidjson::Document& d, LevelData& outLevelData)</code>:</h4>
        <ul>
            <li>Clears previous data in <code>outLevelData</code>.</li>
            <li>Parses top-level fields: <code>levelName</code>, <code>levelNumber</code>, <code>playerStart</code>, <code>backgroundColor</code>.</li>
            <li>Iterates through the <code>"platforms"</code> JSON array:
                <ul>
                    <li>For each platform JSON object:
                        <ul>
                            <li>Parses <code>id</code>, <code>position</code>, <code>size</code>, <code>type</code> (using <code>stringToBodyType()</code>), <code>surfaceVelocity</code>, <code>initiallyFalling</code>.</li>
                            <li>Creates a <code>phys::PlatformBody</code> and adds to <code>outLevelData.platforms</code>.</li>
                            <li>If type is <code>moving</code>, parses the corresponding <code>"movement"</code> block from JSON into <code>outLevelData.movingPlatformDetails</code>.</li>
                            <li>If type is <code>interactible</code>, parses <code>"interaction"</code> into <code>outLevelData.interactiblePlatformDetails</code>.</li>
                             <li>If type is <code>portal</code>, parses <code>"portalID"</code> and optional <code>"teleportOffset"</code> into <code>outLevelData.portalPlatformDetails</code>.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <h4><code>stringToBodyType(const std::string& typeStr) const</code>:</h4>
        <p>Converts string from JSON to <code>phys::bodyType</code> enum.</p>


        <h3 id="detailed-platform-body">8.3. <code>PlatformBody.hpp</code> and <code>.cpp</code></h3>
        <h4>Purpose:</h4>
        <p>Represents a physical platform object in the game world. It's primarily a data container for properties used by the <code>CollisionSystem</code> and game logic in <code>main.cpp</code>.</p>
        <h4>Key Members:</h4>
        <ul>
            <li><code>m_id</code>: Unique identifier for the platform within a level. Used to link to <code>MovingPlatformInfo</code>, <code>InteractiblePlatformInfo</code>, etc.</li>
            <li><code>m_position</code>: Top-left corner coordinates.</li>
            <li><code>m_velocity</code>: (Currently unused directly by <code>PlatformBody</code> itself; moving platforms have their velocity/position managed externally in <code>main.cpp</code>).</li>
            <li><code>m_width</code>, <code>m_height</code>: Dimensions.</li>
            <li><code>m_type</code>: <code>phys::bodyType</code> enum, defining its physical behavior.</li>
            <li><code>m_falling</code>: Boolean state, primarily relevant for <code>bodyType::falling</code>. (Actual fall mechanics are driven by <code>Tile</code> and <code>main.cpp</code>).</li>
            <li><code>m_surfaceVelocity</code>: Velocity applied to entities on this platform (for <code>bodyType::conveyorBelt</code>).</li>
            <li><code>m_portalID</code>, <code>m_teleportOffset</code>: For <code>bodyType::portal</code>.</li>
        </ul>
        <h4>Methods:</h4>
        <ul>
            <li>Constructor: Initializes all members.</li>
            <li>Getters: <code>getID()</code>, <code>getPosition()</code>, <code>getWidth()</code>, <code>getHeight()</code>, <code>getAABB()</code>, <code>getType()</code>, <code>isFalling()</code>, <code>getSurfaceVelocity()</code>, <code>getPortalID()</code>, <code>getTeleportOffset()</code>.</li>
            <li>Setters: <code>setPosition()</code>, <code>setFalling()</code>, <code>setType()</code>, <code>setPortalID()</code>, <code>setTeleportOffset()</code>.</li>
            <li><code>getAABB() const</code>: Returns an <code>sf::FloatRect</code> representing the bounding box, essential for collision detection.</li>
            <li><code>update(float deltaTime)</code>: In the current code, this is minimal. For <code>bodyType::falling</code>, it has a placeholder. The complex update logic (moving, falling visuals, vanishing) is primarily handled in <code>main.cpp</code> by querying the <code>PlatformBody</code>'s <code>id</code> and <code>type</code> and then directly manipulating its state or associated <code>Tile</code>.</li>
        </ul>


        <h3 id="detailed-player">8.4. <code>Player.hpp</code> and <code>.cpp</code> (Class <code>phys::DynamicBody</code>)</h3>
        <h4>Purpose:</h4>
        <p>Represents the player character or any other dynamic, physics-enabled entity. In this game, it's exclusively used for the player.</p>
        <h4>Key Members:</h4>
        <ul>
            <li><code>m_position</code>: Current top-left position.</li>
            <li><code>m_velocity</code>: Current velocity (pixels per second).</li>
            <li><code>m_lastPosition</code>: Position at the start of the last fixed physics update. Used by <code>CollisionSystem</code> to understand the frame's displacement.</li>
            <li><code>m_width</code>, <code>m_height</code>: Player's dimensions.</li>
            <li><code>m_onGround</code>: Boolean, set by <code>CollisionSystem</code> and <code>main.cpp</code> logic. True if the player is considered to be on a surface.</li>
            <li><code>m_groundPlatform</code>: Pointer to the <code>PlatformBody</code> the player is currently standing on. Can be <code>nullptr</code>.</li>
            <li><code>m_isTryingToDrop</code>: Boolean. Set true from input if player presses 'S' while on ground. Used by <code>CollisionSystem</code> to allow dropping through <code>bodyType::platform</code> platforms.</li>
            <li><code>m_tempIgnoredPlatform</code>: Pointer to a <code>PlatformBody</code> that should be ignored for collision detection for the current physics iteration (e.g., the platform being dropped through).</li>
            <li><code>m_maxSpeed</code>, <code>m_acceleration</code>: (Defined but not currently used in the player's movement logic in <code>main.cpp</code>. Player speed is set directly.)</li>
        </ul>
        <h4>Methods:</h4>
        <ul>
            <li>Constructor: Initializes position, size, velocity.</li>
            <li>Getters: <code>getPosition()</code>, <code>getVelocity()</code>, <code>getLastPosition()</code>, <code>getWidth()</code>, <code>getHeight()</code>, <code>getAABB()</code>, <code>getLastAABB()</code>, <code>isOnGround()</code>, <code>getGroundPlatform()</code>, <code>isTryingToDropFromPlatform()</code>, <code>getGroundPlatformTemporarilyIgnored()</code>.</li>
            <li>Setters: <code>setPosition()</code>, <code>setVelocity()</code>, <code>addVelocity()</code>, <code>setLastPosition()</code>, <code>setOnGround()</code>, <code>setGroundPlatform()</code>, <code>setTryingToDrop()</code>, <code>setGroundPlatformTemporarilyIgnored()</code>.</li>
            <li><code>getAABB() const</code>: Returns player's current bounding box.</li>
            <li><code>getLastAABB() const</code>: Returns player's bounding box at <code>m_lastPosition</code>.</li>
        </ul>

        <h3 id="detailed-tile">8.5. <code>Tile.hpp</code> and <code>.cpp</code></h3>
        <h4>Purpose:</h4>
        <p>The visual representation of a <code>PlatformBody</code>. It's a drawable SFML entity that can also manage its own simple animations or states, like falling. It's distinct from the physical <code>PlatformBody</code>.</p>
        <h4>Key Members:</h4>
        <ul>
            <li><code>m_shape</code>: <code>sf::RectangleShape</code> used for drawing.</li>
            <li><code>m_isFalling</code>: Boolean, true if the tile is currently in its falling animation.</li>
            <li><code>m_fallDelayTimer</code>: <code>sf::Time</code>. If set, the tile will start falling after this delay.</li>
            <li><code>m_hasFallen</code>: Boolean, true if the tile has completed its fall (e.g., gone off-screen).</li>
            <li><code>m_fallSpeed</code>: Speed at which the tile descends during its falling animation.</li>
        </ul>
        <h4>Inheritance:</h4>
        <p><code>public sf::Drawable</code>, <code>public sf::Transformable</code>. Allows it to be drawn and positioned/scaled/rotated.</p>
        <h4>Methods:</h4>
        <ul>
            <li>Constructor: Initializes size and color of <code>m_shape</code>.</li>
            <li><code>startFalling(sf::Time delay)</code>: Initiates the falling sequence. Sets <code>m_fallDelayTimer</code>. Only works if not already falling/fallen.</li>
            <li><code>update(sf::Time deltaTime)</code>:
                <ul>
                    <li>Decrements <code>m_fallDelayTimer</code>. If it reaches zero, sets <code>m_isFalling = true</code>.</li>
                    <li>If <code>m_isFalling && !m_hasFallen</code>: Moves the tile downwards by <code>m_fallSpeed * deltaTime</code>. If it moves below a certain Y limit (<code>FALLEN_Y_LIMIT</code>, or <code>600.f</code> in <code>Tile.cpp</code>), sets <code>m_hasFallen = true</code> and <code>m_isFalling = false</code>.</li>
                </ul>
            </li>
            <li>Getters/Setters: <code>setFillColor()</code>, <code>getFillColor()</code>, <code>setTexture()</code>.</li>
            <li><code>getGlobalBounds() const</code>, <code>getLocalBounds() const</code>: Standard SFML bounds functions. <code>getGlobalBounds()</code> returns an empty rect if <code>m_hasFallen</code>.</li>
            <li><code>draw(sf::RenderTarget& target, sf::RenderStates states) const override</code>:
                <ul>
                    <li>Draws <code>m_shape</code> to the target if <code>!m_hasFallen</code>. Applies the tile's transform.</li>
                </ul>
            </li>
        </ul>


        <h2 id="main-game-loop">9. Main Game Loop (<code>main.cpp</code>) Overview</h2>
        <p>This file is the heart of the game, tying all systems together.</p>
        <h3 id="main-loop-init">9.1 Game Initialization:</h3>
        <ul>
            <li>Sets up SFML window, views (<code>uiView</code> for UI, <code>mainView</code> for game world).</li>
            <li>Initializes <code>LevelManager</code> (paths, max levels, transition properties).</li>
            <li>Loads audio (<code>loadAudio()</code>), fonts, UI text elements.</li>
            <li>Initializes <code>playerBody</code>.</li>
            <li>Populates screen resolutions (<code>populateAvailableResolutions()</code>).</li>
            <li>Starts with <code>currentState = GameState::MENU</code> and plays menu music.</li>
        </ul>

        <h3 id="main-loop-event">9.2 Event Handling (<code>while (window.pollEvent(event))</code>):</h3>
        <ul>
            <li>Handles window close, F4 (skip level), mouse clicks, and keyboard presses.</li>
            <li>Behavior depends heavily on the current <code>GameState</code>.
                <ul>
                    <li><code>MENU</code>/<code>SETTINGS</code>/<code>CREDITS</code>/<code>GAME_OVER_*</code>: UI button interactions, state changes, volume adjustments.</li>
                    <li><code>PLAYING</code>: Escape to menu, 'R' to respawn, 'E' to set <code>interactKeyPressedThisFrame</code>.</li>
                </ul>
            </li>
            <li>Updates mouse position for UI interaction (<code>worldPosUi</code>).</li>
        </ul>

        <h3 id="main-loop-fixed-update">9.3 Fixed Update Loop (<code>while (timeSinceLastFixedUpdate >= TIME_PER_FIXED_UPDATE)</code>):</h3>
        <ul>
            <li>Ensures game logic runs at a consistent rate (default 60 FPS).</li>
            <li>Only active if <code>currentState == GameState::PLAYING</code>.</li>
            <li><strong>Player Input & Velocity:</strong>
                <ul>
                    <li>Reads horizontal input (A/D, Left/Right), jump input (W/Up/Space), drop input (S/Down), turbo (Shift).</li>
                    <li>Updates <code>playerBody.getVelocity().x</code>.</li>
                    <li>Applies gravity if <code>!playerBody.isOnGround()</code>.</li>
                    <li>Handles jump initiation and variable jump height (<code>currentJumpHoldDuration</code>).</li>
                    <li>Sets <code>playerBody.isTryingToDrop()</code>.</li>
                </ul>
            </li>
            <li><strong>Platform Updates:</strong>
                <ul>
                    <li><strong>Moving Platforms:</strong> Iterates <code>activeMovingPlatforms</code>, calculates new position using easing functions based on <code>cycleTime</code> and movement parameters, updates <code>PlatformBody::m_position</code> and corresponding <code>Tile::m_position</code>. Stores <code>lastFrameActualPosition</code>.</li>
                    <li><strong>Interactible Cooldowns:</strong> Updates <code>currentCooldownTimer</code> for <code>activeInteractibles</code>.</li>
                    <li><strong>Falling/Vanishing Platforms:</strong>
                        <ul>
                            <li>Iterates through <code>bodies</code> and <code>tiles</code>.</li>
                            <li>Finds the <code>template_body_ptr</code> from <code>currentLevelData.platforms</code> to know the original intended type/position.</li>
                            <li><strong>Falling:</strong> If template is <code>falling</code> and player lands on it, <code>tiles[i].startFalling()</code> is called. <code>Tile::update()</code> handles the visual fall. When <code>tiles[i].hasFallen()</code>, <code>bodies[i].setType(phys::bodyType::none)</code> and its position is moved off-screen.</li>
                            <li><strong>Vanishing:</strong> If template is <code>vanishing</code>, calculates alpha based on <code>vanishingPlatformCycleTimer</code>, <code>oddEvenVanishing</code>, and easing. If alpha is low, <code>bodies[i].setType(phys::bodyType::none)</code> and moved off-screen. Otherwise, <code>bodies[i].setType(phys::bodyType::vanishing)</code> and moved to its <code>originalPos</code>. <code>Tile</code> color/alpha is updated.</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><strong>Collision Resolution:</strong> <code>phys::CollisionSystem::resolveCollisions(playerBody, bodies, fixed_dt_seconds)</code>.</li>
            <li><strong>Post-Collision Player Logic:</strong>
                <ul>
                    <li>If player is on ground: conveyor belt logic, sticking to moving platforms, spring logic.</li>
                    <li>Handles ceiling hits.</li>
                </ul>
            </li>
            <li><strong>Trap Check:</strong> Iterates bodies; if player AABB intersects a <code>trap</code> type, sets game state to <code>GAME_OVER_LOSE_DEATH</code>.</li>
            <li><strong>Interaction (Goal, Interactibles - if 'E' pressed):</strong>
                <ul>
                    <li>Goal: If player intersects a <code>goal</code> type, loads next level or sets <code>GAME_OVER_WIN</code>.</li>
                    <li>Interactibles: If player intersects an <code>interactible</code> type, checks cooldowns/<code>oneTime</code>. If "changeSelf", modifies <code>bodies[k].setType()</code> and <code>tiles[k].setFillColor()</code>.</li>
                </ul>
            </li>
            <li><strong>Death by Falling:</strong> If <code>playerBody.getPosition().y > PLAYER_DEATH_Y_LIMIT</code>, sets game state to <code>GAME_OVER_LOSE_FALL</code>.</li>
        </ul>

        <h3 id="main-loop-transition">9.4 Transition Handling (Outside Fixed Update):</h3>
        <ul>
            <li>If <code>currentState == GameState::TRANSITIONING</code>:
                <ul>
                    <li><code>levelManager.update()</code> is called.</li>
                    <li>If transition finishes (<code>!levelManager.isTransitioning()</code>):
                        <ul>
                            <li><code>setupLevelAssets(currentLevelData, window)</code> is called. This populates <code>bodies</code>, <code>tiles</code>, <code>activeMovingPlatforms</code>, <code>activeInteractibles</code> based on the newly loaded <code>currentLevelData</code>.</li>
                            <li><code>currentState</code> is set to <code>PLAYING</code>. Music is switched.</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>

        <h3 id="main-loop-drawing">9.5 Drawing:</h3>
        <ul>
            <li><code>window.clear()</code> with appropriate background color.</li>
            <li><code>switch(currentState)</code>:
                <ul>
                    <li><code>MENU</code>/<code>SETTINGS</code>/<code>CREDITS</code>/<code>GAME_OVER_*</code>: Sets <code>uiView</code>, draws UI elements (background, text, buttons). Highlights buttons on mouse hover.</li>
                    <li><code>PLAYING</code>: Sets <code>mainView</code> (camera follows player). Draws all <code>tiles</code> (if not fallen/transparent), then <code>playerShape</code>. Draws debug text using <code>uiView</code>.</li>
                    <li><code>TRANSITIONING</code>: <code>levelManager.draw(window)</code> handles drawing fades/loading screens.</li>
                </ul>
            </li>
            <li><code>window.display()</code>.</li>
        </ul>

        <h2 id="general-debugging-tips">10. General Debugging Tips</h2>
        <ul>
            <li><strong>Print, Print, Print:</strong> Use <code>std::cout</code> or <code>sf::Text</code> to display variable values at crucial points.
                <ul>
                    <li>Player position, velocity, onGround status.</li>
                    <li>Platform IDs, types, positions.</li>
                    <li>Collision event times and axes.</li>
                    <li>Current game state.</li>
                    <li>JSON parsing results.</li>
                </ul>
            </li>
            <li><strong>Isolate the Problem:</strong> If a complex system fails, try to break it down.
                <ul>
                    <li>Is player input registered correctly?</li>
                    <li>Is the platform data loaded correctly from JSON?</li>
                    <li>Does <code>sweptAABB</code> work for a simple case?</li>
                </ul>
            </li>
            <li><strong>Use the Debug Text:</strong> The in-game debug overlay already shows level, player pos/vel, and ground status. Enhance it if needed.</li>
            <li><strong>Check Console Output:</strong> <code>LevelManager</code> and RapidJSON print error messages to the console for file/parsing issues.</li>
            <li><strong>Step Through with a Debugger:</strong> If available in your IDE, a debugger is invaluable for inspecting variables and call stacks.</li>
            <li><strong>Simplify the Level:</strong> If a bug occurs in a complex level, try to reproduce it in a minimal test level with only the relevant platforms.</li>
            <li><strong>Check Coordinate Systems and AABBs:</strong> Ensure positions and AABBs are what you expect. <code>sf::RectangleShape</code> can be used to visually draw AABBs for debugging.</li>
            <li><strong>Understand State Machines:</strong> Many issues arise from incorrect state transitions or conditions (e.g., player <code>m_onGround</code>, <code>LevelManager::m_transitionState</code>, game's <code>currentState</code>).</li>
             <li><strong>The "Blink" Test for Vanishing/Falling:</strong> If a platform of these types is behaving erratically, temporarily make it a <code>solid</code> block at its intended active position. If that works, the issue is likely in the state-change logic (timing, conditions for becoming <code>none</code> or <code>vanishing</code>, position updates). Ensure <code>originalPos</code> for vanishing blocks is correctly obtained from <code>currentLevelData.platforms</code> and used when the block fades <em>in</em>.</li>
        </ul>
    </div>
</body>
</html>
